"Inversion of control (IOC)" is a design principle where the control of object creation and
lifecycle management is transferred from Application code to the external container or framework.

"Dependency Injection (DI)" is a design principle where the dependencies of the program are
provided externally rather than being created within the class itself.
DI is used to achieve Loose Coupling between classes.

- Construction injection: Dependencies are provided to the classes using constructors.
    Constructors are provided as arguments. This ensures that dependencies are available when the object is created.



BEANS -
objects that are managed by the frameworks are "Beans", done through configuring file in package.

- Bean definition:
It includes configuration metadata that the container needs to know to create and manager beans.
- Bean configuration:
Definition of beans can be provided in many ways: XML configuration files, annotations and java-based configurations.
In configuration using XML file, the beans are defined within the <bean> tags with attributes specifying class, properties and dependencies.
Annotations include: @Component, @Service, @Repository, etc. these are picked by Spring and managed as beans.

LIFECYCLE OF BEAN:
Instantiation -> setting up bean properties -> Initialization -> Ready for use -> Destructed.


"Spring Containerization" is the process of keeping multiple objects within 1 container,
which is based on the configuration file definition of the classes to be managed.
Types:-
1. Application Context - Mostly used.
2. BeanFactory - Provides basic support for dependency injection, simplest.

Dependencies to add in 'pom.xml' file-
-> Maven Repository: 1. Spring-Core, 2. Spring-Context


"Autowiring" is to automatically resolve and inject dependencies between beans without requiring any explicit explanation in XML configuration.
For "Autowiring" two classes are required where one is dependent on the other.
Autowiring can be done in 3 ways:
- TYPE (the object type, ie. Specifications of a car)
- NAME (bean id)
- CONSTRUCTOR

"Annotations" - these are the ways of adding metadata to the spring code.
@Override - above the method way of telling something to the Java compiler.
@Component - marks java class as bean / or a manage component.
@Autowired - Spring will autowire dependency and the type of dependency on its declaration in xml.
@Qualifier - when we have multiple matching types, qualifier helps with 'which bean should be matched where.'
@Value - Used to inject property values in our beans.
@Repository - Used to define the data repository (specialized version of components annotation).
@Service - indicates that this particular class is providing business services.
@Controller - Used to create web controllers, they handle http request.
@RequestMapping
@SpringBootApplication

------

Components & componentScan :
Component refers to a Java class which is managed by the Spring IoC container (manages the spring beans). These are the building blocks.
It is in a way a bean only - it is just designed to be auto-detected and configured from class path scanning. "We don't have to manually define this in the xml file as we had to, with the beans."
Defining components:
- using XML =>  <bean id = "myComponent" class = "com.example.components"/>

- using Annotations =>
import org.springframework.stereotype.Component;

@Component // this marks the class as Spring annotation
public class Component{
// implementation of class
}

:: Component scanning is a feature that automatically detects and registers beans from predefined package paths.
